{
  "items": {
    "root": {
      "type": "group",
      "items": [
        "documents",
        "modules",
        "classes"
      ],
      "itemTypeCounts": {
        "group": 3
      },
      "isSorted": true,
      "isHomePath": true
    },
    "modules": {
      "type": "group",
      "key": "modules",
      "name": "Modules",
      "items": [
        "lib/util",
        "lib/nice-ast",
        "lib/ast-node",
        "lib/render",
        "lib/report",
        "lib/transform",
        "lib/doctor",
        "lib/cli"
      ],
      "groups": [
        "root"
      ],
      "itemTypeCounts": {
        "module": 8
      }
    },
    "classes": {
      "type": "group",
      "key": "classes",
      "name": "Classes",
      "items": [
        "lib/ast-node.class.AstNode",
        "lib/report.class.Report"
      ],
      "groups": [
        "root"
      ],
      "itemTypeCounts": {
        "class": 2
      }
    },
    "documents": {
      "key": "documents",
      "type": "group",
      "name": "Documents",
      "groups": [
        "root"
      ],
      "items": [
        "toc.2",
        "document.README.md"
      ],
      "itemTypeCounts": {
        "group": 1,
        "document": 1
      },
      "isHomePath": true
    },
    "toc.2": {
      "key": "toc.2",
      "name": "Examples",
      "type": "group",
      "groups": [
        "documents"
      ],
      "isSorted": true
    },
    "lib/util": {
      "type": "module",
      "key": "lib/util",
      "name": "util",
      "description": "<p>This module contains various utility functions used by doctor.\n\n</p>\n<p>It notably contains some nasty synchronous versions of asynchronous modules.\n\n</p>\n<p>Say what?\n\n</p>\n<p>Yeah, that&#39;s right. This is so doctor can run synchronously or ansynhronously.\nDoctor wants to run asynchronously, so when we have to run synchronously (such\nas during that ugly startup phase where you have to deal with synchronous\nrequire), we have to fake it out with synchronous versions of asynchronous\nmodules. This is ugly, but it&#39;s better than having to write two different\nversions of doctor.</p>",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/util.findRules",
        "lib/util.findFunctions",
        "lib/util.findFile",
        "lib/util.findDir",
        "lib/util.compareFileDates",
        "lib/util.toArray",
        "lib/util.localizePaths",
        "lib/util.cleanUndefinedProperties",
        "lib/util.isCapitalized",
        "lib/util.sync.findRules",
        "lib/util.sync.findFunctions",
        "lib/util.sync.findFile",
        "lib/util.sync.findDir",
        "lib/util.sync.compareFileDates",
        "lib/util.sync.toArray",
        "lib/util.sync.localizePaths",
        "lib/util.sync.cleanUndefinedProperties",
        "lib/util.sync.isCapitalized",
        "lib/util.sync.async.forEachSeries",
        "lib/util.sync.async.detect",
        "lib/util.sync.async.some",
        "lib/util.sync.async.forEach"
      ],
      "itemTypeCounts": {
        "function": 22
      }
    },
    "lib/util.findRules": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.findRules",
      "params": [
        {
          "name": "options"
        },
        {
          "name": "optionRules",
          "description": "<p>Rule modules.</p>",
          "types": [
            "Array",
            "string"
          ]
        },
        {
          "name": "defaultDir",
          "description": "<p>Default directory for rules.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Require the specified rule modules, either from the default location or from\nthe user-specified location.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "findRules",
      "signatures": []
    },
    "lib/util.findFunctions": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.findFunctions",
      "params": [
        {
          "name": "optionFunctions"
        },
        {
          "name": "defaultDir"
        }
      ],
      "description": "<p>Require the specified function modules, either in the default location or\nthe user-specified location.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "findFunctions",
      "signatures": []
    },
    "lib/util.findFile": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.findFile",
      "params": [
        {
          "name": "fileList",
          "description": "<p>Possible files to find.</p>",
          "types": [
            "Array"
          ]
        },
        {
          "name": "ifCb",
          "description": "<p>If one is found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "elseCb",
          "description": "<p>If one is not found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "sync",
          "description": "<p>Flag to force function to run synchronously.</p>",
          "types": [
            "boolean"
          ]
        }
      ],
      "description": "<p>Find one of a list of files.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "findFile",
      "signatures": []
    },
    "lib/util.findDir": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.findDir",
      "params": [
        {
          "name": "dirList",
          "description": "<p>Possible directories to find.</p>",
          "types": [
            "Array"
          ]
        },
        {
          "name": "ifCb",
          "description": "<p>If one is found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "elseCb",
          "description": "<p>If one is not found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "sync",
          "description": "<p>Flag to force function to run synchronously.</p>",
          "types": [
            "boolean"
          ]
        }
      ],
      "description": "<p>Find one of a list of directories.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "findDir",
      "signatures": []
    },
    "lib/util.compareFileDates": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.compareFileDates",
      "params": [
        {
          "name": "a",
          "description": "<p>Path to first file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "b",
          "description": "<p>Path to second file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with comparison value.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "sync",
          "description": "<p>Flag to force function to run synchronously.</p>",
          "types": [
            "boolean"
          ]
        }
      ],
      "description": "<p>Compare the modified time stamps of two files.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "compareFileDates",
      "signatures": []
    },
    "lib/util.toArray": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.toArray",
      "params": [
        {
          "name": "maybeArray",
          "description": "<p>Array or value.</p>"
        }
      ],
      "description": "<p>Take an array or a value, and if it&#39;s a value, wrap it in an array.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "toArray",
      "signatures": []
    },
    "lib/util.localizePaths": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.localizePaths",
      "params": [
        {
          "name": "pathList",
          "description": "<p>List of absolute paths.</p>",
          "types": [
            "Array"
          ]
        }
      ],
      "description": "<p>Compress absolute paths down to minimal non-colliding lengths.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "localizePaths",
      "signatures": []
    },
    "lib/util.cleanUndefinedProperties": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.cleanUndefinedProperties",
      "params": [
        {
          "name": "obj",
          "description": "<p>Object to copy.</p>"
        }
      ],
      "description": "<p>Create a copy of the object without the undefined properties.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "cleanUndefinedProperties",
      "signatures": []
    },
    "lib/util.isCapitalized": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.isCapitalized",
      "params": [
        {
          "name": "string",
          "description": "<p>String to check.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Check if string starts with a captial letter.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "isCapitalized",
      "signatures": []
    },
    "lib/util.sync.findRules": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.findRules",
      "params": [
        {
          "name": "options"
        },
        {
          "name": "optionRules",
          "description": "<p>Rule modules.</p>",
          "types": [
            "Array",
            "string"
          ]
        },
        {
          "name": "defaultDir",
          "description": "<p>Default directory for rules.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Require the specified rule modules, either from the default location or from\nthe user-specified location.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.findRules",
      "signatures": []
    },
    "lib/util.sync.findFunctions": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.findFunctions",
      "params": [
        {
          "name": "optionFunctions"
        },
        {
          "name": "defaultDir"
        }
      ],
      "description": "<p>Require the specified function modules, either in the default location or\nthe user-specified location.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.findFunctions",
      "signatures": []
    },
    "lib/util.sync.findFile": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.findFile",
      "params": [
        {
          "name": "fileList",
          "description": "<p>Possible files to find.</p>",
          "types": [
            "Array"
          ]
        },
        {
          "name": "ifCb",
          "description": "<p>If one is found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "elseCb",
          "description": "<p>If one is not found, do this.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Find one of a list of files.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.findFile",
      "signatures": []
    },
    "lib/util.sync.findDir": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.findDir",
      "params": [
        {
          "name": "dirList",
          "description": "<p>Possible directories to find.</p>",
          "types": [
            "Array"
          ]
        },
        {
          "name": "ifCb",
          "description": "<p>If one is found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "elseCb",
          "description": "<p>If one is not found, do this.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Find one of a list of directories.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.findDir",
      "signatures": []
    },
    "lib/util.sync.compareFileDates": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.compareFileDates",
      "params": [
        {
          "name": "a",
          "description": "<p>Path to first file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "b",
          "description": "<p>Path to second file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with comparison value.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Compare the modified time stamps of two files.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.compareFileDates",
      "signatures": []
    },
    "lib/util.sync.toArray": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.toArray",
      "params": [
        {
          "name": "maybeArray",
          "description": "<p>Array or value.</p>"
        }
      ],
      "description": "<p>Take an array or a value, and if it&#39;s a value, wrap it in an array.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.toArray",
      "signatures": []
    },
    "lib/util.sync.localizePaths": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.localizePaths",
      "params": [
        {
          "name": "pathList",
          "description": "<p>List of absolute paths.</p>",
          "types": [
            "Array"
          ]
        }
      ],
      "description": "<p>Compress absolute paths down to minimal non-colliding lengths.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.localizePaths",
      "signatures": []
    },
    "lib/util.sync.cleanUndefinedProperties": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.cleanUndefinedProperties",
      "params": [
        {
          "name": "obj",
          "description": "<p>Object to copy.</p>"
        }
      ],
      "description": "<p>Create a copy of the object without the undefined properties.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.cleanUndefinedProperties",
      "signatures": []
    },
    "lib/util.sync.isCapitalized": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.isCapitalized",
      "params": [
        {
          "name": "string",
          "description": "<p>String to check.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Check if string starts with a captial letter.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.isCapitalized",
      "signatures": []
    },
    "lib/util.sync.async.forEachSeries": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.async.forEachSeries",
      "params": [
        {
          "name": "array"
        },
        {
          "name": "eachCb"
        },
        {
          "name": "finalCb"
        }
      ],
      "description": "<p>Synchronous forEachSeries, with an asynchronous signature. Because it&#39;s\nsynchronous, it can also be used as the forEach function.\n\n</p>\n<p>See the async module for details.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.async.forEachSeries",
      "signatures": []
    },
    "lib/util.sync.async.detect": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.async.detect",
      "params": [
        {
          "name": "array"
        },
        {
          "name": "passCb"
        },
        {
          "name": "resultCb"
        }
      ],
      "description": "<p>Synchronous detect, with an asynchronous signature.\n\n</p>\n<p>See the async module for details.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.async.detect",
      "signatures": []
    },
    "lib/util.sync.async.some": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.async.some",
      "params": [
        {
          "name": "array"
        },
        {
          "name": "passCb"
        },
        {
          "name": "doneCb"
        }
      ],
      "description": "<p>Synchronous some, with an asynchronous signature.\n\n</p>\n<p>See the async module for details.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.async.some",
      "signatures": []
    },
    "lib/util.sync.async.forEach": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.async.forEach",
      "params": [
        {
          "name": "array"
        },
        {
          "name": "eachCb"
        },
        {
          "name": "finalCb"
        }
      ],
      "description": "<p>Synchronous forEachSeries, with an asynchronous signature. Because it&#39;s\nsynchronous, it can also be used as the forEach function.\n\n</p>\n<p>See the async module for details.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.async.forEach",
      "signatures": []
    },
    "lib/nice-ast": {
      "type": "module",
      "key": "lib/nice-ast",
      "name": "nice-ast",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/nice-ast.walk",
        "lib/nice-ast.walkEnd",
        "lib/nice-ast.extendAst",
        "lib/nice-ast.cleanAst",
        "lib/nice-ast.astFromFile",
        "lib/nice-ast.astFromSource",
        "lib/nice-ast.walkWithRules",
        "lib/nice-ast.pegParser",
        "lib/nice-ast.lispify",
        "lib/nice-ast.like",
        "lib/nice-ast.equal",
        "lib/nice-ast.parserForGrammar"
      ],
      "itemTypeCounts": {
        "function": 12
      }
    },
    "lib/nice-ast.walk": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.walk",
      "params": [
        {
          "name": "node",
          "description": "<p>AST node to walk.</p>",
          "types": [
            "AstNode",
            "Object"
          ],
          "properties": [
            {
              "name": ".type",
              "description": "<p>Each AST node needs a type.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Each AST node can optionally have a list of nodes to recurse.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            }
          ]
        },
        {
          "name": "beforeCb",
          "description": "<p>Function to call before recursing into node.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "afterCb",
          "description": "<p>Function to call after recursing into node.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Walks a tree of AST nodes.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "walk",
      "signatures": []
    },
    "lib/nice-ast.walkEnd": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.walkEnd",
      "params": [
        {
          "name": "node",
          "description": "<p>AST node to walk.</p>",
          "types": [
            "AstNode",
            "Object"
          ],
          "properties": [
            {
              "name": ".type",
              "description": "<p>Each AST node needs a type.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Each AST node can optionally have a list of nodes to\nrecurse.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            }
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call before and after recursing into node.\nAfter recursing node, pseudo-node of type &quot;end&quot; will be passed to callback.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Walks a tree of AST nodes.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "walkEnd",
      "signatures": []
    },
    "lib/nice-ast.extendAst": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.extendAst",
      "params": [
        {
          "name": "node",
          "description": "<p>Plain object representing a node.</p>",
          "types": [
            "Object"
          ],
          "properties": [
            {
              "name": ".type",
              "description": "<p>Type of the node.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Child nodes that will also be converted.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            }
          ]
        },
        {
          "name": "parent",
          "description": "<p>Parent AstNode in the tree.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Takes a plain object representing a node, converts it to an AstNode and attaches\nit to a parent in an AstNode tree.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "extendAst",
      "signatures": []
    },
    "lib/nice-ast.cleanAst": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.cleanAst",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to convert.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Converts a node (and its descendants) into plain objects that can be serialized.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "cleanAst",
      "signatures": []
    },
    "lib/nice-ast.astFromFile": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.astFromFile",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "file",
          "description": "<p>File name.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with AST.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Convert file to AST.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "astFromFile",
      "signatures": []
    },
    "lib/nice-ast.astFromSource": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.astFromSource",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "source",
          "description": "<p>Source code.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "extension",
          "description": "<p>File extension for source file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with AST.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Convert source code to an AST.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "astFromSource",
      "signatures": []
    },
    "lib/nice-ast.walkWithRules": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.walkWithRules",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "rules",
          "description": "<p>One or more rules file names.</p>",
          "types": [
            "Array",
            "String"
          ]
        },
        {
          "name": "defaultDir",
          "description": "<p>Default location for rules modules.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "ast",
          "description": "<p>Root of AST.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "nodeCb",
          "description": "<p>Function to call for each node.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "finalCb",
          "description": "<p>Function to call when finished walking.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Walk a tree of AST nodes and apply rules.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "walkWithRules",
      "signatures": []
    },
    "lib/nice-ast.pegParser": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.pegParser",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "extension",
          "description": "<p>File extension.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with peg parser.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Given doctor options and a file extension, retrieve an appropriate peg parser.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "pegParser",
      "signatures": []
    },
    "lib/nice-ast.lispify": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.lispify",
      "params": [
        {
          "name": "node",
          "description": "<p>AST node to lispify.</p>",
          "types": [
            "AstNode",
            "Object"
          ]
        }
      ],
      "description": "<p>Convert a node to a lisp-like string, useful for debugging rules.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "lispify",
      "signatures": []
    },
    "lib/nice-ast.like": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.like",
      "params": [
        {
          "name": "a",
          "description": "<p>Node to test for comparison. Must have all the\nproperties of node b.</p>",
          "types": [
            "AstNode",
            "Object"
          ]
        },
        {
          "name": "b",
          "description": "<p>Node that has a partial set of node a&#39;s properties.</p>",
          "types": [
            "AstNode",
            "Object"
          ]
        }
      ],
      "description": "<p>Determine if a node is &quot;like&quot; another node, meaning it has all the properties of\nthat node.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "like",
      "signatures": []
    },
    "lib/nice-ast.equal": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.equal",
      "params": [
        {
          "name": "a",
          "description": "<p>Example node.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "b",
          "description": "<p>Node that should match a&#39;s properties.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "diff",
          "optional": true
        }
      ],
      "description": "<p>Tests two AST nodes for equality.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "equal",
      "signatures": []
    },
    "lib/nice-ast.parserForGrammar": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.parserForGrammar",
      "params": [
        {
          "name": "grammarFile",
          "description": "<p>Name of grammar file.</p>",
          "types": [
            "String"
          ]
        }
      ],
      "description": "<p>Return the PEG parser for a given grammar file.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "parserForGrammar",
      "signatures": []
    },
    "lib/ast-node": {
      "type": "module",
      "key": "lib/ast-node",
      "name": "ast-node",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/ast-node.exports-AstNode"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/ast-node.class.AstNode": {
      "type": "class",
      "module": "lib/ast-node",
      "key": "lib/ast-node.class.AstNode",
      "name": "AstNode",
      "groups": [
        "classes"
      ],
      "items": [
        "lib/ast-node.exports-AstNode",
        "lib/ast-node.class.AstNode.item",
        "lib/ast-node.class.AstNode.fix",
        "lib/ast-node.class.AstNode.index",
        "lib/ast-node.class.AstNode.walk",
        "lib/ast-node.class.AstNode.after",
        "lib/ast-node.class.AstNode.before",
        "lib/ast-node.class.AstNode.prepend",
        "lib/ast-node.class.AstNode.append",
        "lib/ast-node.class.AstNode.remove",
        "lib/ast-node.class.AstNode.lispify",
        "lib/ast-node.class.AstNode.like",
        "lib/ast-node.class.AstNode.equal",
        "lib/ast-node.class.AstNode.parser",
        "lib/ast-node.class.AstNode.likeSource",
        "lib/ast-node.class.AstNode.ast",
        "lib/ast-node.class.AstNode.fromSource",
        "lib/ast-node.class.AstNode.nodeFromSource"
      ],
      "itemTypeCounts": {
        "module-function": 1,
        "function": 17
      }
    },
    "lib/ast-node.exports-AstNode": {
      "type": "module-function",
      "isConstructor": true,
      "key": "lib/ast-node.exports-AstNode",
      "params": [
        {
          "name": "node",
          "description": "<p>Plain object to use as template for node.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "parent",
          "description": "<p>Parent node of this node.</p>",
          "types": [
            "AstNode"
          ],
          "optional": true
        }
      ],
      "classDescription": {
        "description": "<p>Represents an AST node.</p>"
      },
      "description": "<p>Creates an AST node from a plain object.</p>",
      "properties": [
        {
          "name": "parent",
          "description": "<p>Parent of this node.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "prev",
          "description": "<p>Previous sibling of this node.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "next",
          "description": "<p>Next sibling of this node.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "_items",
          "isPrivate": true
        }
      ],
      "examples": [
        "var node = new AstNode({type: 'string', value: 'Hello, world!'});"
      ],
      "groups": [
        "lib/ast-node",
        "lib/ast-node.class.AstNode"
      ],
      "name": "AstNode",
      "signatures": []
    },
    "lib/ast-node.class.AstNode.item": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.item",
      "params": [
        {
          "name": "key",
          "description": "<p>Item key.</p>"
        },
        {
          "name": "value",
          "description": "<p>Item value.</p>"
        }
      ],
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "item",
      "signatures": [
        {
          "description": "<p>Gets an item value from a node. If the node doesn&#39;t have the item\nkey, a recursive search will continue up through the parents.</p>",
          "returns": {
            "description": "<p>Value for this item.</p>"
          },
          "arity": 1,
          "params": [
            {
              "name": "key",
              "description": "<p>Item key.</p>"
            }
          ]
        },
        {
          "description": "<p>Sets an item value for a particular node. Node items act like scoped\nvariables. Values set for a parent node can be seen by children nodes.</p>",
          "arity": 2,
          "params": [
            {
              "name": "key",
              "description": "<p>Item key.</p>"
            },
            {
              "name": "value",
              "description": "<p>Item value.</p>"
            }
          ]
        }
      ],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.fix": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.fix",
      "params": [
        {
          "name": "index"
        }
      ],
      "description": "<p>Properly connect siblings to this node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "fix",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.index": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.index",
      "params": [],
      "returns": {
        "description": "",
        "types": [
          "integer"
        ]
      },
      "description": "<p>Get the index of a node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "index",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.walk": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.walk",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to walk.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Walk this node and its children, using the registered walk method. When a\nnode is appended, this is used to run all the rules for the appended node and\nits children.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "walk",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.after": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.after",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to insert.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Insert node after this one.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "after",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.before": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.before",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to insert.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Insert node before this one.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "before",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.prepend": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.prepend",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to prepend.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Insert a new child node before any other child nodes.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "prepend",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.append": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.append",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to append.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Insert a new child node after any other child nodes.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "append",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.remove": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.remove",
      "params": [],
      "description": "<p>Remove this node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "remove",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.lispify": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.lispify",
      "params": [],
      "returns": {
        "description": "",
        "types": [
          "string"
        ]
      },
      "description": "<p>Return a lisp-like representation of this node. Useful for debugging rules.\nGives you a terse look at the AST.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "lispify",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.like": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.like",
      "params": [
        {
          "name": "node",
          "description": "<p>Node that has a subset of nodes/properties.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "returns": {
        "description": "",
        "types": [
          "boolean"
        ]
      },
      "description": "<p>Returns true if this node has everything that node has.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "like",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.equal": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.equal",
      "params": [
        {
          "name": "node",
          "description": "<p>Node that has identical nodes/properties.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "returns": {
        "description": "",
        "types": [
          "boolean"
        ]
      },
      "description": "<p>Return true if this node is idential to node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "equal",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.parser": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.parser",
      "params": [],
      "returns": {
        "description": "<p>PEG parser.</p>"
      },
      "description": "<p>Get the PEG parser used to create this AST.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "parser",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.likeSource": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.likeSource",
      "params": [
        {
          "name": "source",
          "description": "<p>Source code to parse and compare to this node.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Compare this node to some arbitrary source. The source string will be\ncompiled to an AST, using the same grammar that was used to create this node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "likeSource",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.ast": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.ast",
      "params": [],
      "returns": {
        "description": "<p>Plain object.</p>",
        "types": [
          "Object"
        ]
      },
      "description": "<p>Return an AST without the sibling and parent references.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "ast",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.fromSource": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.fromSource",
      "params": [
        {
          "name": "source",
          "description": "<p>Source code.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "returns": {
        "description": "<p>AST.</p>",
        "types": [
          "Object"
        ]
      },
      "description": "<p>Create an AST from source code.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "fromSource",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.nodeFromSource": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.nodeFromSource",
      "params": [
        {
          "name": "source",
          "description": "<p>Source code.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "returns": {
        "description": "<p>AST node.</p>",
        "types": [
          "Object"
        ]
      },
      "description": "<p>Create an AST node from source code.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "nodeFromSource",
      "signatures": [],
      "isMethod": true
    },
    "lib/render": {
      "type": "module",
      "key": "lib/render",
      "name": "render",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/render.exports-render"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/render.exports-render": {
      "type": "module-function",
      "isConstructor": false,
      "key": "lib/render.exports-render",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "report",
          "description": "<p>Report generated by doctor.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call when rendering is complete.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Render the report with the render modules supplied in the options.</p>",
      "groups": [
        "lib/render"
      ],
      "name": "render",
      "signatures": []
    },
    "lib/report": {
      "type": "module",
      "key": "lib/report",
      "name": "report",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/report.exports-run"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/report.exports-run": {
      "type": "module-function",
      "isConstructor": false,
      "key": "lib/report.exports-run",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "ast",
          "description": "<p>AST.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call when finished.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Run an AST through a set of rules and return a report in a callback.</p>",
      "groups": [
        "lib/report"
      ],
      "name": "run",
      "signatures": []
    },
    "lib/report.class.Report": {
      "type": "class",
      "key": "lib/report.class.Report",
      "name": "Report",
      "groups": [
        "classes"
      ],
      "items": [
        "lib/report.class.Report.run",
        "lib/report.class.Report.item",
        "lib/report.class.Report.remove",
        "lib/report.class.Report.add",
        "lib/report.class.Report.home"
      ],
      "itemTypeCounts": {
        "function": 5
      }
    },
    "lib/report.class.Report.run": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.run",
      "params": [
        {
          "name": "cb",
          "description": "<p>Function to call when finished walking and applying rules\nto the AST.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Run the report through the supplied report rules.</p>",
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "run",
      "signatures": [],
      "isMethod": true
    },
    "lib/report.class.Report.item": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.item",
      "params": [
        {
          "name": "key",
          "description": "<p>Key of report item.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "item"
        }
      ],
      "returns": {
        "description": "<p>Object representing a report item.</p>",
        "types": [
          "Object"
        ]
      },
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "item",
      "signatures": [
        {
          "description": "<p>Returns a report item.</p>",
          "arity": 1,
          "params": [
            {
              "name": "key",
              "description": "<p>Key of report item.</p>",
              "types": [
                "String"
              ]
            }
          ]
        }
      ],
      "isMethod": true
    },
    "lib/report.class.Report.remove": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.remove",
      "params": [
        {
          "name": "key",
          "description": "<p>Key of report item.</p>",
          "types": [
            "String"
          ]
        }
      ],
      "description": "<p>Removes a report item.</p>",
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "remove",
      "signatures": [],
      "isMethod": true
    },
    "lib/report.class.Report.add": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.add",
      "params": [
        {
          "name": "item",
          "description": "<p>Report item.</p>",
          "types": [
            "String"
          ]
        }
      ],
      "description": "<p>Adds a report item.</p>",
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "add",
      "signatures": [],
      "isMethod": true
    },
    "lib/report.class.Report.home": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.home",
      "params": [
        {
          "name": "item"
        }
      ],
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "home",
      "signatures": [
        {
          "description": "<p>Gets the key of the home item for the report.</p>",
          "returns": {
            "description": "<p>Key of the home item.</p>",
            "types": [
              "String"
            ]
          },
          "arity": 0,
          "params": []
        },
        {
          "description": "<p>Sets the key of the home item for the report.</p>",
          "arity": 1,
          "params": [
            {
              "name": "item",
              "description": "<p>Key of the home item.</p>",
              "types": [
                "String"
              ]
            }
          ]
        }
      ],
      "isMethod": true
    },
    "lib/transform": {
      "type": "module",
      "key": "lib/transform",
      "name": "transform",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/transform.exports-transform"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/transform.exports-transform": {
      "type": "module-function",
      "isConstructor": false,
      "key": "lib/transform.exports-transform",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "ast",
          "description": "<p>AST.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call when transformation is complete.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Transform the AST with the supplied transform rules.</p>",
      "groups": [
        "lib/transform"
      ],
      "name": "transform",
      "signatures": []
    },
    "lib/doctor": {
      "type": "module",
      "key": "lib/doctor",
      "name": "doctor",
      "description": "<p>Main module.</p>",
      "examples": [
        "var doctor = require('doctor');"
      ],
      "groups": [
        "modules"
      ],
      "items": [
        "lib/doctor.examine",
        "lib/doctor.harmony",
        "lib/doctor.hookEnterExit",
        "lib/doctor._callEnterHook",
        "lib/doctor._callExitHook",
        "lib/doctor.insertEnterExitHooksSync",
        "lib/doctor._callHook",
        "lib/doctor._wrapCall"
      ],
      "itemTypeCounts": {
        "function": 8
      }
    },
    "lib/doctor.examine": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor.examine",
      "params": [
        {
          "name": "options",
          "description": "<p>Options for doctor.</p>",
          "types": [
            "Object"
          ],
          "properties": [
            {
              "name": ".files",
              "description": "<p>One or more source files to inspect.</p>",
              "types": [
                "Array",
                "String"
              ]
            },
            {
              "name": ".output",
              "description": "<p>Directory or filename for where to output the report file. If true, uses\n    default output directory name of &quot;output&quot;.</p>",
              "types": [
                "String",
                "boolean"
              ]
            },
            {
              "name": ".view",
              "description": "<p>One or more view directories to merge into output directory. If true, uses\n    default view.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".report",
              "description": "<p>One or more report modules. If true, uses default report module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".transform",
              "description": "<p>One or more transform modules. If true, uses default transform module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".render",
              "description": "<p>One or more render modules. If true, uses default render module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".grammar",
              "description": "<p>Grammar file to use or a map of grammar files to use for each source\n    extension.</p>",
              "types": [
                "String",
                "Object"
              ]
            }
          ]
        },
        {
          "name": "progressCb",
          "description": "<p>Function to call with progress messages.</p>",
          "types": [
            {
              "type": "function",
              "params": [
                "progress"
              ]
            }
          ],
          "optional": true
        },
        {
          "name": "cb",
          "description": "<p>Function to call when doctor is finished.</p>",
          "types": [
            {
              "type": "function",
              "params": [
                "err",
                "report"
              ]
            }
          ]
        }
      ],
      "description": "<p>Parses the AST of a set of JavaScript files, uses report rules to convert the\nAST into a report, and optionally combines the report with the view or\nrenders the report into an output format.</p>",
      "examples": [
        "var doctor = require('doctor');\nvar options = {\n  files: ['package.json'],\n  view: ['default', 'doctor']\n};\ndoctor.examine(options, function (err, report) {\n  console.log(JSON.stringify(report));\n})"
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "examine",
      "signatures": []
    },
    "lib/doctor.harmony": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor.harmony",
      "params": [],
      "description": "<p><strong>EXPERIMENTAL!</strong> <strong>(and not even close to finished)</strong> Registers a compiler\nfor the .js extension that will compile harmony files to ECMAScript 5.</p>",
      "visibility": "private",
      "groups": [
        "lib/doctor"
      ],
      "name": "harmony",
      "signatures": [],
      "isPrivate": true
    },
    "lib/doctor.hookEnterExit": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor.hookEnterExit",
      "params": [
        {
          "name": "options",
          "description": "<p>{Object|RegExp} Pass in a regular expression apply the compiler\nonly to paths matching that regular expression.</p>"
        },
        {
          "name": "enterCb",
          "description": "<p>{function} Calls this function (passing it info) when a\nfunction is entered.</p>",
          "optional": true
        },
        {
          "name": "exitCb",
          "description": "<p>{Fucntion} Calls this function (passing it info) when a function\nis exited.</p>"
        }
      ],
      "description": "<p><strong>EXPERIMENTAL!</strong> Registers a compiler for the .js extension that will catch\nfunction entry/exit.</p>",
      "examples": [
        "var doctor = require('doctor');\n\nfunction hookMessage(title, info) {\n  return title + \" \" + info.name + \":\\n\" +\n    \"  type:   \" + info.type + \"\\n\" +\n    \"  line:   \" + info.line + \"\\n\" +\n    \"  column: \" + info.column + \"\\n\" +\n    \"  path:   \" + info.filename;\n}\n\ndoctor.hookEnterExit(\n  /foobar/,\n  function (info) {\n    console.log(hookMessage(\"Enter\", info));\n  },\n  function (info) {\n    console.log(hookMessage(\"Exit\", info));\n  }\n);\n\nrequire('./foobar');"
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "hookEnterExit",
      "signatures": []
    },
    "lib/doctor._callEnterHook": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor._callEnterHook",
      "params": [],
      "groups": [
        "lib/doctor"
      ],
      "name": "_callEnterHook",
      "signatures": [],
      "isPrivate": true
    },
    "lib/doctor._callExitHook": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor._callExitHook",
      "params": [],
      "groups": [
        "lib/doctor"
      ],
      "name": "_callExitHook",
      "signatures": [],
      "isPrivate": true
    },
    "lib/doctor.insertEnterExitHooksSync": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor.insertEnterExitHooksSync",
      "params": [
        {
          "name": "filename",
          "description": "<p>{String} Filename of file to trasform. Callback hooks are\nregistered to this filename.</p>"
        },
        {
          "name": "enterCb",
          "description": "<p>{function} Function to call when entering function. If exitCb\nis not defined, enterCb will be called for exit as well.</p>",
          "optional": true
        },
        {
          "name": "exitCb",
          "description": "<p>{function} Function to call when exiting function.</p>",
          "optional": true
        },
        {
          "name": "sourceCb",
          "description": "<p>{function} Function to call when building the source for a function.</p>",
          "optional": true
        }
      ],
      "description": "<p><strong>EXPERIMENTAL</strong> Inserts enter/exit hooks into a JavaScript file. Registers\ncallback hooks for that file.</p>",
      "examples": [
        "var doctor = require('doctor');\n\nvar source = doctor.insertEnterExitHooksSync('foobar.js', function (info) {\n  console.log(JSON.stringify(info, null, 2));\n});\n\neval(source);"
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "insertEnterExitHooksSync",
      "signatures": []
    },
    "lib/doctor._callHook": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor._callHook",
      "params": [
        {
          "name": "type"
        },
        {
          "name": "filename"
        },
        {
          "name": "info"
        }
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "_callHook",
      "signatures": [],
      "isPrivate": true
    },
    "lib/doctor._wrapCall": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor._wrapCall",
      "params": [
        {
          "name": "fn"
        },
        {
          "name": "ctx"
        },
        {
          "name": "args"
        },
        {
          "name": "filename"
        },
        {
          "name": "info"
        }
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "_wrapCall",
      "signatures": [],
      "isPrivate": true
    },
    "lib/cli": {
      "type": "module",
      "key": "lib/cli",
      "name": "cli",
      "description": "<p>Command-line interface into doctor.</p>",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/cli.exports-cli"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/cli.exports-cli": {
      "type": "module-function",
      "isConstructor": false,
      "key": "lib/cli.exports-cli",
      "params": [
        {
          "name": "argv",
          "description": "<p>Just the command-line arguments. In other words,\nprocess.argv.slice(2).</p>",
          "types": [
            "Object"
          ]
        }
      ],
      "description": "<p>Map command-line arguments to doctor&#39;s examine function.</p>",
      "groups": [
        "lib/cli"
      ],
      "name": "cli",
      "signatures": []
    },
    "document.README.md": {
      "key": "document.README.md",
      "name": "Overview",
      "type": "document",
      "content": "<h1>doctor</h1>\n<p><a href=\"http://travis-ci.org/jdeal/doctor\"><img src=\"https://secure.travis-ci.org/jdeal/doctor.png\" alt=\"Build Status\"></a>\n\n</p>\n<p><strong>Doctor is still under development, so be careful.</strong> It is probably stable enough to be useful, but no promises.\n\n</p>\n<p><img src=\"https://github.com/jdeal/doctor/raw/master/images/pinch-points-warning-143.png\" alt=\"pinch\">\n\n</p>\n<p>Doctor converts JavaScript source to documentation, using rules to rely on\nconventions so that comment tags are (mostly) not needed.\n\n</p>\n<h2>Say what?</h2>\n<p>Maybe a picture will help:\n\n</p>\n<p><img src=\"https://github.com/jdeal/doctor/raw/master/images/doctor-pipeline.png\" alt=\"pipeline\">\n\n</p>\n<p>Okay, maybe that needs some explanation.\n\n</p>\n<p>Source files are parsed using a JavaScript grammar. This pushes out a plain\nLisp-like AST. This is refined with some transform rules. The default transform\nrules also use a grammar to parse the JSDoc-style comment tags. This is to add\nin things that cannot be inferred from the JavaScript source, such as function\ndescription and parameter types.\n\n</p>\n<p>Rules are applied to the refined AST to output a report, which is just a flat\nJSON object containing items and groups of items. The report is optionally run\nthrough a render module to convert the report to some format other than a single\nJSON file.\n\n</p>\n<p>Doctor also provides an option that takes a number of view directories and\nmerges them together into a single output directory, along with the report\nfile(s). A default HTML/JavaScript view is provided to view the default report\nas HTML.\n\n</p>\n<p>Doctor has initial (rough) support for markdown as well, integrating that into\nthe report if passed along with the source.\n\n</p>\n<p>Because of its modular and somewhat pluggable design, you can hack in your own\ngrammars, rules, etc. and use it as a general-purpose AST analysis tool.\n\n</p>\n<h2>Installation</h2>\n<pre><code class=\"lang-bash\">npm install doctor</code></pre>\n<p>or if you want the latest\n\n</p>\n<pre><code class=\"lang-bash\">npm install git:github.com/jdeal/doctor.git</code></pre>\n<h2>Examples, please!</h2>\n<p>Note that these examples assume a shell that expands wildcards.\n\n</p>\n<p>This is how doctor documents itself from the command-line:\n\n</p>\n<pre><code class=\"lang-bash\">doctor lib/*.js *.md -v default -v doctor -o ../doc</code></pre>\n<p>You can see the documentation <a href=\"http://jdeal.github.com/doctor/doc\">here</a>.\n\n</p>\n<p>The above command (when run from inside doctor&#39;s repository directory) takes all\nthe .js files and all the .md files and runs them through the default transform\nand default report rules. It puts the report into ../doc and merges the default\nand doctor views into ../doc. For many of doctor&#39;s options, it will look for a\nbuilt-in resource first and then try to find it in the directory provided. In\nthis example, doctor has views named default and doctor, so it finds them in\nitself. If an alternate view was provided, say my-view, it would look for that\npath, whether it be local or absolute.\n\n</p>\n<p>These and other options are described in more detail in the command-line section\nbelow.\n\n</p>\n<p>You can also look at the <a href=\"http://jdeal.github.com/doctor/tree/master/examples\">examples</a>.\n\n</p>\n<h2>Command-line usage</h2>\n<p>Dump a report file to the console:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js</code></pre>\n<p>If no output directory is provided, doctor will throw the report (or whatever is\nrequested, such as the raw AST) to the the console.\n\n</p>\n<p>To write out the report file, give it a directory:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js -o output</code></pre>\n<p>Doctor will write the report to a file named report.json. If you prefer a\ndifferent name:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js -o output/myreport.json</code></pre>\n<p>When doctor sees the .json extension like this, it assumes you mean to rename\nthe report.\n\n</p>\n<p>You can also pass package.json files to doctor. It will use the main property to\nfind the source file:\n\n</p>\n<pre><code class=\"lang-bash\">doctor package.json -o output</code></pre>\n<p>To output the default viewer along with your report:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js -o output -v default</code></pre>\n<p>The default viewer files will be located in the output directory along with your\nreport.\n\n</p>\n<p>To merge your own files into the view, pass multiple views:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js -o output -v default -v ~/my-view</code></pre>\n<p>When multiple views are passed, they are processed in order. So, if a later view\ncan overwrite a previous view&#39;s files. This is useful when you want a view to\ndiffer only slightly. This is how doctor documents itself, by overriding the\nconfig file of the default view.\n\n</p>\n<p>You can override the grammar if you feel adenturous:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js --grammar ~/my-better-grammar.pegjs</code></pre>\n<p>Note that the JavaScript grammar is pretty complicated, so you probably want to\nuse doctor&#39;s included grammar (in grammar/javascript.pegjs) as a starting point.\n\n</p>\n<p>You can override the grammar for a specific file extension. This is necessary if\nyou want to alter the JavaScript grammar for .js while leaving the markdown\ngrammar registered for .md.\n\n</p>\n<pre><code class=\"lang-bash\">doctor source.js readme.md --grammar.js ~/my-js-gramar.pegjs</code></pre>\n<p>You can add your own transform rules:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js -t default -t ~/more-tranform-rules.js</code></pre>\n<p>Transform rules are useful for modifying the AST prior to creating reports.\nThey&#39;re powerful, but also easy to mess up. Look at doctor&#39;s own transform rules\n(transform/default) for examples, or look in the examples directory for simpler\nexamples.\n\n</p>\n<p>Perhaps most important, you can add your own report rules:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js -r default -r ~/more-report-rules.js</code></pre>\n<p>This is what doctor is all about. You can look at doctor&#39;s own rules\n(report/default), but these are pretty complicated. Some simpler examples are\nin the examples directory.\n\n</p>\n<p>You can also use a custom renderer:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js myfile2.js --render ~/my-render.js</code></pre>\n<p>This allows you to modify the resulting JSON report or convert it to something\nelse entirely. Doctor&#39;s default renderer exists only to convert markdown to\nHTML. You&#39;ll also find a markdown renderer (default/markdown) which is meant\nto convert the JSON to markdown files, but this is not finished.\n\n</p>\n<p>By default, doctor passes unknown JSDoc tags through to the report, but you can\nhave it complain if it sees unknown tags:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js --no-unknown</code></pre>\n<p>Any of the default enabled options (grammar, transform, report, render, and\nunknown) can be disabled by prefixing the option with no-.\n\n</p>\n<p>You can force doctor to return its AST like this:\n\n</p>\n<pre><code class=\"lang-bash\">doctor myfile1.js --no-transform --no-report --ast</code></pre>\n<p>Notice that we turned of the transform and report rules in this example. We\ncould leave the transform rules enabled if we wanted to see the AST after\ntransformation. If we leave the report active, we&#39;ll get an object returned\nthat contains the AST and the report.\n\n</p>\n<h2>Programmatic usage</h2>\n<p>All the same options are available programmatically.\n\n</p>\n<pre><code class=\"lang-js\">var doctor = require(&#39;doctor&#39;);\nvar options = {\n  files: [&#39;myfile1.js&#39;, &#39;myfile2.js&#39;],\n  view: [&#39;default&#39;, &#39;~/my-view&#39;],\n  grammar: &#39;~/my-better-grammar.pegjs&#39;,\n  transform: [&#39;default&#39;, &#39;~/more-tranform-rules.js&#39;],\n  report: {js:\n    [&#39;default&#39;, &#39;~/more-report-rules.js&#39;]\n  },\n  render: &#39;default&#39;,\n  unknown: false,\n  output: &#39;~/documentation&#39;\n};\ndoctor.examine(options, function (err, report) {\n  // done\n});</code></pre>\n<h2>API</h2>\n<p>For writing transform and report rules, you&#39;ll need to learn doctor&#39;s API. You\ncan see doctor&#39;s own documentation for that:\n\n</p>\n<p><a href=\"http://jdeal.github.com/doctor/doc\">http://jdeal.github.com/doctor/doc</a>\n\n</p>\n<h2>Conventions</h2>\n<p>The default rules supplied by doctor (report/default) will document the\nfollowing conventions in your code. (In this section, <em>doctor</em> may refer to\ndoctor and its default rules.)\n\n</p>\n<h3>CommonJS modules</h3>\n<p>Doctor only documents the public API, via CommonJS exports.\n\n</p>\n<pre><code class=\"lang-js\">exports.foo = function () {};</code></pre>\n<pre><code class=\"lang-js\">module.exports = {foo: function () {}}</code></pre>\n<pre><code class=\"lang-js\">module.exports = function () {}</code></pre>\n<p>Note that doctor can find many variations of the above patterns. For example,\nit can generally see when you&#39;re setting variables and then exporting those\nvariables, even if you&#39;re setting the variables to other required modules. If\ndoctor can&#39;t figure out what you&#39;re exporting, there&#39;s a good chance humans also\ncan&#39;t figure it out.\n\n</p>\n<h3>AMD modules</h3>\n<p>Doctor sees AMD-style exports as well.\n\n</p>\n<pre><code class=\"lang-js\">define(function () {\n  return {foo: function () {}};\n});</code></pre>\n<p>Again, it can see some variations of\nthis, although it may not be quite as resilient as node-style exports.\n\n</p>\n<h3>Function parameters</h3>\n<p>Of course, doctor documents parameters of exported functions.\n\n</p>\n<pre><code class=\"lang-js\">function foo(bar) {}</code></pre>\n<h3>Optional parameters</h3>\n<p>Doctor can see where a parameter is given a default value.\n\n</p>\n<pre><code class=\"lang-js\">function foo(bar) {\n  bar = bar || &#39;baz&#39;;\n}</code></pre>\n<h3>Constructors</h3>\n<p>Doctor will assume upper-case functions are constructors.\n\n</p>\n<pre><code class=\"lang-js\">function Foo() {}\n\nmodule.exports = Foo;</code></pre>\n<h3>Instances</h3>\n<p>Doctor can see when an instance is exported.\n\n</p>\n<pre><code class=\"lang-js\">function Foo() {}\n\nFoo.prototype.bar = function () {};\n\nmodule.exports = new Foo();</code></pre>\n<p>Given that export, doctor knows your module has exported a function named bar.\n\n</p>\n<h3>Following dependencies</h3>\n<p>Doctor can follow require.\n\n</p>\n<pre><code class=\"lang-js\">var bar = require(&#39;./bar&#39;);\n\nexports.bar = bar;</code></pre>\n<p>And it can follow AMD dependencies.\n\n</p>\n<pre><code class=\"lang-js\">define([&#39;./bar&#39;], function (bar) {\n  return {bar: bar};\n});</code></pre>\n<p>Note that doctor will only document what is passed to it. It will not document\ndependent modules, except when they are exported from a passed-in module.\n\n</p>\n<p>So, if the above code is part of foo.js, and you call doctor like this:\n\n</p>\n<pre><code class=\"lang-bash\">doctor lib/foo.js</code></pre>\n<p>bar.js will not be documented, even though doctor follows it.\n\n</p>\n<h3>Literal prototypes</h3>\n<pre><code class=\"lang-js\">function Foo() {\n}\n\nFoo.prototype = {\n  bar: function () {\n  }\n}</code></pre>\n<h2>JSDoc tags</h2>\n<p>Where doctor cannot infer documentation from convention, JSDoc tags can be used\nto annotate the code.\n\n</p>\n<p>Note that you can use multi-line or single-line comment style.\n\n</p>\n<h3>@description</h3>\n<p>Add a description to a function, using markdown.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@description Returns a greeting.\n*/\nfunction hello() {\n  return &quot;Hello!&quot;;\n}</code></pre>\n<p>If a comment appears with no tag, it is assumed to be a description.\n\n</p>\n<pre><code class=\"lang-js\">/*\nReturns a greeting.\n*/\nfunction hello() {\n  return &quot;Hello!&quot;;\n}</code></pre>\n<h3>@param</h3>\n<p>Add a description and optional type to a function parameter.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@param {string} name - Name of a person.\n*/\nfunction greeting(name) {\n  return &quot;Hello, &quot; + name + &quot;.&quot;;\n}</code></pre>\n<p>Note the optional dash (-) which can be used to visually separate the\ndescription.\n\n</p>\n<p>Note that doctor will match the parameters to the name of the function. So a\nfunction like this:\n\n</p>\n<pre><code class=\"lang-js\">/*\n@param {number} y - The y, of course.\n*/\nfunction foo(x, y, z) {\n  return x * y + z;\n}</code></pre>\n<p>will add a description to the y parameter. This is different from JSDoc which\nmatches the parameters by position.\n\n</p>\n<p>If a parameter is an object with certain properties, you can document the\nproperties like this:\n\n</p>\n<pre><code class=\"lang-js\">/*\n@param {object} car - The car.\n@param {number} car.speed - The speed of the car.\n*/\nfunction drive(car) {\n  console.log(&quot;The car is going &quot; + car.speed + &quot;mph.&quot;);\n}</code></pre>\n<p>If a parameter is a function with certain parameters, you can document the\nparameters like this:\n\n</p>\n<pre><code class=\"lang-js\">/*\n@param {function(err, message)} callback - Function to call when finished.\n*/\nfunction waitAndThen(callback) {\n  setTimeout(function () {\n    callback(null, &quot;hello&quot;);\n  }, 1000);\n}</code></pre>\n<p>Note that doctor&#39;s default view doesn&#39;t do anything except parrot these\nparameters, but they are available in the report.\n\n</p>\n<p>Optional parameters can be documented with brackets, and default values can be\ndocumented with an assignment.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@param {string} [name = &quot;you&quot;] - Name of a person.\n*/\nfunction greeting(name) {\n  name = name || &quot;you&quot;;\n  return &quot;Hello, &quot; + name + &quot;.&quot;;\n}</code></pre>\n<p>As noted above though, this is unnecessary, as doctor can see the convention for\noptional parameters.\n\n</p>\n<h3>@return, @returns</h3>\n<p>Document the return type of a function.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@returns string\n*/\nfunction foo() {\n  return &quot;bar&quot;;\n}</code></pre>\n<h3>@class</h3>\n<p>Add a description for the class.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@class A useful widget.\n*/\nfunction UsefulWidget() {\n\n}</code></pre>\n<h3>@constructor</h3>\n<p>Add a description for the constructor.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@constructor Makes a widget.\n*/\nfunction UsefulWidget() {\n\n}</code></pre>\n<p>This is not really necessary since doctor sees upper-case functions as\nconstructors. In doctors default view, the constructor description just gets\nconcatenated to the description.\n\n</p>\n<h3>@example</h3>\n<p>Adds example usage to a module or function.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@example\nvar msg = greeting();\n*/\nfunction greeting() {\n  return &quot;Hello!&quot;;\n}</code></pre>\n<h3>@extends</h3>\n<p>Sets the base class for a class.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@extends Widget\n*/\nfunction UsefulWidget() {\n\n}</code></pre>\n<p>(Yes, doctor should be support a convention for this.)\n\n</p>\n<h3>@private, @public</h3>\n<p>Doctor&#39;s default rules assume that everything exported is public and everything\nelse is private.\n\n</p>\n<p>You can explicitly set something to private to hide it in\ndoctor&#39;s default rules.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@private\n*/\nmodule.exports._foo = function () {\n  return &quot;Don&#39;t use me. I&#39;m not documented!&quot;;\n}</code></pre>\n<p>You can explicitly set something to public to force doctor to add it to the\nreport. For example, in some cases, you may export something (say, via a\nreturn value of a function) that doctor doesn&#39;t see as public. If you mark a\nconstructor as public, doctor will automatically add all methods of that class\nto the report as well.\n\n</p>\n<pre><code class=\"lang-js\">/*\nSecret constructor.\n\n@class Secret maker.\n\n@public\n*/\nfunction Secret() {\n}</code></pre>\n<h3>@signature</h3>\n<p>This allows documenting alternate signatures of a single function. For example,\na setter and getter can sometimes be the same function. The @signature parameter\nset the description for these signatures and allows overriding parameter \ndescriptions.\n\n</p>\n<pre><code class=\"lang-js\">/*\n@param name - Attribute name.\n*/\nfunction attr(name, value) {\n/*\n@signature Get attribute value.\n@param value - Attribute value.\n*/\n  if (typeof value === &#39;undefined&#39;) {\n\n  }\n/*\n@signature Set attribute value.\n*/\n}</code></pre>\n<h3>@copy</h3>\n<p>This allows copying the tags from another function in the case that one\nfunction shares parameters or descriptions with another function.\n\n</p>\n<pre><code class=\"lang-js\">/*\nCreate a TPS report.\n@param name - Author of the report.\n@param verbose - Add \n*/\nfunction createTpsReport(name, verbose) {\n  return {\n    name: name,\n    summary: &quot;I didn&#39;t get any cake.&quot;\n  }\n  if (verbose) {\n    console.log(&quot;wasting time...&quot;);\n  }\n}\n\n/*\n@copy createTpsReprot\n*/\nfunction createVerboseTpsReport(name) {\n  createTpsReport(name, true);\n}</code></pre>\n<h3>@abstract</h3>\n<p>Really? What, are you a Java programmer?\n\n</p>\n<p>Fine, this marks a class as abstract.\n\n</p>\n<h2>Writing custom rules</h2>\n<p>Doctor&#39;s default rules are useful for normal documentation tasks, but you can do\nall kinds of neat things by writing your own rules.\n\n</p>\n<p>A rules module should export an array of rules or an object with a &quot;rules&quot;\nproperty. If multiple rules match the same AST node type, then they will fire\nin the order in which they declare.\n\n</p>\n<h3>Transform rules</h3>\n<p>Transform rules follow this pattern:\n\n</p>\n<pre><code class=\"lang-js\">{\n  type: &#39;define-function&#39;,\n  match: function (node) {\n    var name = node.nodes[0].value;\n    return name === &#39;foo&#39;;\n  },\n  transform: function (node, report) {\n    node.remove();\n  }\n}</code></pre>\n<p><strong>type</strong>\n\n</p>\n<p>This property should be a string specifying the AST node type or an array of\nnode types. Note that you can use pseudo-end node types, for which rules will\nfire after all descendent node rules have fired. For example, define-function\nhas a corresponding end-define-function which will fire after the entire body\nof the function has been processed.\n\n</p>\n<p><strong>match</strong> (optional)\n\n</p>\n<p>This property is an optional function that can further filter the node.\n\n</p>\n<p><strong>transform</strong>\n\n</p>\n<p>This property is a function that is called to transform the node.\n\n</p>\n<h3>Report rules</h3>\n<p>Report rules follow this pattern:\n\n</p>\n<pre><code class=\"lang-js\">{\n  type: &#39;define-function&#39;,\n  match: function (node) {\n    var name = node.nodes[0].value;\n    return name === &#39;foo&#39;;\n  },\n  report: function (node, report) {\n    var name = node.nodes[0].value;\n    return {\n      key: &#39;define-function:&#39; + name,\n      name: name\n    }\n  }\n}</code></pre>\n<p><strong>type</strong>\n\n</p>\n<p>This property should be a string specifying the AST node type or an array of\nnode types. Note that you can use pseudo-end node types, for which rules will\nfire after all descendent node rules have fired. For example, define-function\nhas a corresponding end-define-function which will fire after the entire body\nof the function has been processed.\n\n</p>\n<p><strong>match</strong> (optional)\n\n</p>\n<p>This property is an optional function that can further filter the node.\n\n</p>\n<p><strong>report</strong>\n\n</p>\n<p>This property is a function that manipulates the report, either via the report\nparameter or by returning a report item or an array of report items.\n\n</p>\n<h2>AST node types</h2>\n<p>If you write your own rules, you&#39;ll need to know the following AST node types.\n\n</p>\n<p>As noted above, each AST node type has a corresponding end type. So\ndefine-function has a matching end-define-function.\n\n</p>\n<h3>files</h3>\n<p>A group of all files. Rules for this node type (and the corresponding end-files)\nwill fire only once.\n\n</p>\n<h3>file</h3>\n<p>Each file.\n\n</p>\n<h3>undefined</h3>\n<p>Undefined node. For example: if an else clause of an if statement is\nundefined, the else clause will be an undefined node.\n\n</p>\n<h3>name</h3>\n<p>An identifier. For example: a function name, a variable name.\n\n</p>\n<h3>number</h3>\n<p>A number. For example: 3, 5.6.\n\n</p>\n<h3>string</h3>\n<p>A string. For example: &quot;hello&quot;.\n\n</p>\n<h3>null</h3>\n<p>A null literal.\n\n</p>\n<h3>boolean</h3>\n<p>A boolean literal (true or false).\n\n</p>\n<h3>regex</h3>\n<p>A literal regular expression.\n\n</p>\n<h3>regex-body</h3>\n<p>The body (between the slashes) of a regular expression.\n\n</p>\n<h3>regex-flags</h3>\n<p>The flags (after the second slash) of a regular expression.\n\n</p>\n<h3>this</h3>\n<p>The &quot;this&quot; keyword.\n\n</p>\n<h3>object</h3>\n<p>A literal object.\n\n</p>\n<h3>property</h3>\n<p>A key and value set of a literal object.\n\n</p>\n<h3>get</h3>\n<p>Getter.\n\n</p>\n<h3>set</h3>\n<p>Setter.\n\n</p>\n<h3>new</h3>\n<p>Using new to instantiate an object with a constructor.\n\n</p>\n<h3>dot</h3>\n<p>Using dot to access a property or method. For example: foo.bar, foo.baz().\n\n</p>\n<h3>call</h3>\n<p>A function call.\n\n</p>\n<h3>subscript</h3>\n<p>Using brackets to access a property or index. For example: foo[0], foo[&quot;bar&quot;].\n\n</p>\n<h3>expression</h3>\n<p>A parenthetical expression. For example: (3 + 5), (a || b).\n\n</p>\n<h3>postfix</h3>\n<p>A postfix expression. For example: x--, i++.\n\n</p>\n<h3>operator</h3>\n<p>The operator used in an expression.\n\n</p>\n<h3>unary</h3>\n<p>A unary prefix expression. For example: --x, ++i;\n\n</p>\n<h3>binary</h3>\n<p>An binary expression. For example: 3 + 5, a || b.\n\n</p>\n<h3>conditional</h3>\n<p>A conditional expression.\n\n</p>\n<h3>assign</h3>\n<p>Assignment of a value to a variable.\n\n</p>\n<h3>vars</h3>\n<p>A group of variable declarations.\n\n</p>\n<h3>var</h3>\n<p>A single variable declaration.\n\n</p>\n<h3>empty</h3>\n<p>An empty statment, which basically means a semicolon by itself.\n\n</p>\n<h3>if</h3>\n<p>An if statement.\n\n</p>\n<h3>do-while</h3>\n<p>A do-while statement.\n\n</p>\n<h3>while</h3>\n<p>A while statement.\n\n</p>\n<h3>for</h3>\n<p>A for loop.\n\n</p>\n<h3>for-in</h3>\n<p>A for-in loop.\n\n</p>\n<h3>continue</h3>\n<p>A continue statement.\n\n</p>\n<h3>break</h3>\n<p>A break statement.\n\n</p>\n<h3>return</h3>\n<p>A return statement.\n\n</p>\n<h3>with</h3>\n<p>A with statement.\n\n</p>\n<h3>switch</h3>\n<p>A switch statement.\n\n</p>\n<h3>case</h3>\n<p>A case statement of a switch statement.\n\n</p>\n<h3>default</h3>\n<p>A default statement of a switch statement.\n\n</p>\n<h3>nodes</h3>\n<p>A group of AST nodes, which is part of another node. For example, the body of a\nfunction is a node of type &quot;nodes&quot; containing all the nodes of the body.\n\n</p>\n<h3>labeled-statement</h3>\n<p>A labeled statement.\n\n</p>\n<h3>throw</h3>\n<p>A throw.\n\n</p>\n<h3>try</h3>\n<p>A try.\n\n</p>\n<h3>catch</h3>\n<p>A catch clause of a try.\n\n</p>\n<h3>finally</h3>\n<p>A finally clause of a try.\n\n</p>\n<h3>debug</h3>\n<p>A debugger statement.\n\n</p>\n<h3>define-function</h3>\n<p>A function definition.\n\n</p>\n<h3>function</h3>\n<p>A function expression.\n\n</p>\n<h3>parameters</h3>\n<p>The parameters of a function.\n\n</p>\n<h2>FAQ</h2>\n<h3>Why did you do this? Don&#39;t you know [insert here] already exists.</h3>\n<p>Yeah, but [insert here] works off of comment tags and not off of coding\nconventions. And [insert here] doesn&#39;t make it easy to add new conventions. And\n[insert here] isn&#39;t a pure node module. And doctor aims to be a general purpose\ncode analysis tool.\n\n</p>\n<h3>Seriously, why did you do this?</h3>\n<p>Some kind of OCD thing.\n\n</p>\n<h3>Why isn&#39;t this split into two projects, one for the analysis tool and another for code documentation?</h3>\n<p>Maybe it should be. It grew up that way, and I haven&#39;t spent any thought or\neffort on splitting it.\n\n</p>\n<h3>Why is the code so ugly? What&#39;s with all these weird wrapping closures around fs and path?</h3>\n<p>That is thanks to synchronous require. I love node, but I hate synchronous\nrequire. (Yes, I understand why it&#39;s synchronous.) Because I wanted doctor to\nwork asynchronously or synchronously, I had to make asynchronous signatures for\nthe synchronous functions and then swap them out as needed.\n\n</p>\n<p>The rest of the ugliness is my fault.\n\n</p>\n<h3>How do I contribute?</h3>\n<p>The usual: fork, add a (preferably discrete) fix/change with the necessary\ntests, and do a pull request. I can&#39;t promise to respond immediately or even in\na reasonable timeframe, but I&#39;ll do my best to eventually get to it.\n\n</p>\n<h3>Have these questions actually been frequently asked?</h3>\n<p>No, just being proactive.</p>",
      "groups": [
        "documents"
      ],
      "isSorted": true,
      "isHome": true,
      "isHomePath": true
    }
  },
  "home": "document.README.md"
}