{
  "items": {
    "root": {
      "type": "group",
      "items": [
        "documents",
        "modules",
        "classes"
      ],
      "itemTypeCounts": {
        "group": 3
      },
      "isSorted": true,
      "isHomePath": true
    },
    "modules": {
      "type": "group",
      "key": "modules",
      "name": "Modules",
      "items": [
        "lib/util",
        "lib/nice-ast",
        "lib/ast-node",
        "lib/render",
        "lib/report",
        "lib/transform",
        "lib/doctor",
        "lib/cli"
      ],
      "groups": [
        "root"
      ],
      "itemTypeCounts": {
        "module": 8
      }
    },
    "classes": {
      "type": "group",
      "key": "classes",
      "name": "Classes",
      "items": [
        "lib/ast-node.class.AstNode",
        "lib/report.class.Report"
      ],
      "groups": [
        "root"
      ],
      "itemTypeCounts": {
        "class": 2
      }
    },
    "documents": {
      "key": "documents",
      "type": "group",
      "name": "Documents",
      "groups": [
        "root"
      ],
      "items": [
        "document.README.md"
      ],
      "itemTypeCounts": {
        "document": 1
      },
      "isHomePath": true
    },
    "lib/util": {
      "type": "module",
      "key": "lib/util",
      "name": "util",
      "description": "<p>This module contains various utility functions used by doctor.\n\n</p>\n<p>It notably contains some nasty synchronous versions of asynchronous modules.\n\n</p>\n<p>Say what?\n\n</p>\n<p>Yeah, that&#39;s right. This is so doctor can run synchronously or ansynhronously.\nDoctor wants to run asynchronously, so when we have to run synchronously (such\nas during that ugly startup phase where you have to deal with synchronous\nrequire), we have to fake it out with synchronous versions of asynchronous\nmodules. This is ugly, but it&#39;s better than having to write two different\nversions of doctor.</p>",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/util.findRules",
        "lib/util.findFunctions",
        "lib/util.findFile",
        "lib/util.findDir",
        "lib/util.compareFileDates",
        "lib/util.toArray",
        "lib/util.localizePaths",
        "lib/util.cleanUndefinedProperties",
        "lib/util.isCapitalized",
        "lib/util.sync.findRules",
        "lib/util.sync.findFunctions",
        "lib/util.sync.findFile",
        "lib/util.sync.findDir",
        "lib/util.sync.compareFileDates",
        "lib/util.sync.toArray",
        "lib/util.sync.localizePaths",
        "lib/util.sync.cleanUndefinedProperties",
        "lib/util.sync.isCapitalized",
        "lib/util.sync.async.forEachSeries",
        "lib/util.sync.async.detect",
        "lib/util.sync.async.some",
        "lib/util.sync.async.forEach"
      ],
      "itemTypeCounts": {
        "function": 22
      }
    },
    "lib/util.findRules": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.findRules",
      "params": [
        {
          "name": "optionRules",
          "description": "<p>Rule modules.</p>",
          "types": [
            "Array",
            "string"
          ]
        },
        {
          "name": "defaultDir",
          "description": "<p>Default directory for rules.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Require the specified rule modules, either from the default location or from\nthe user-specified location.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "findRules",
      "signatures": []
    },
    "lib/util.findFunctions": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.findFunctions",
      "params": [
        {
          "name": "optionFunctions"
        },
        {
          "name": "defaultDir"
        }
      ],
      "description": "<p>Require the specified function modules, either in the default location or\nthe user-specified location.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "findFunctions",
      "signatures": []
    },
    "lib/util.findFile": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.findFile",
      "params": [
        {
          "name": "fileList",
          "description": "<p>Possible files to find.</p>",
          "types": [
            "Array"
          ]
        },
        {
          "name": "ifCb",
          "description": "<p>If one is found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "elseCb",
          "description": "<p>If one is not found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "sync",
          "description": "<p>Flag to force function to run synchronously.</p>",
          "types": [
            "boolean"
          ]
        }
      ],
      "description": "<p>Find one of a list of files.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "findFile",
      "signatures": []
    },
    "lib/util.findDir": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.findDir",
      "params": [
        {
          "name": "dirList",
          "description": "<p>Possible directories to find.</p>",
          "types": [
            "Array"
          ]
        },
        {
          "name": "ifCb",
          "description": "<p>If one is found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "elseCb",
          "description": "<p>If one is not found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "sync",
          "description": "<p>Flag to force function to run synchronously.</p>",
          "types": [
            "boolean"
          ]
        }
      ],
      "description": "<p>Find one of a list of directories.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "findDir",
      "signatures": []
    },
    "lib/util.compareFileDates": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.compareFileDates",
      "params": [
        {
          "name": "a",
          "description": "<p>Path to first file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "b",
          "description": "<p>Path to second file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with comparison value.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "sync",
          "description": "<p>Flag to force function to run synchronously.</p>",
          "types": [
            "boolean"
          ]
        }
      ],
      "description": "<p>Compare the modified time stamps of two files.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "compareFileDates",
      "signatures": []
    },
    "lib/util.toArray": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.toArray",
      "params": [
        {
          "name": "maybeArray",
          "description": "<p>Array or value.</p>"
        }
      ],
      "description": "<p>Take an array or a value, and if it&#39;s a value, wrap it in an array.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "toArray",
      "signatures": []
    },
    "lib/util.localizePaths": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.localizePaths",
      "params": [
        {
          "name": "pathList",
          "description": "<p>List of absolute paths.</p>",
          "types": [
            "Array"
          ]
        }
      ],
      "description": "<p>Compress absolute paths down to minimal non-colliding lengths.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "localizePaths",
      "signatures": []
    },
    "lib/util.cleanUndefinedProperties": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.cleanUndefinedProperties",
      "params": [
        {
          "name": "obj",
          "description": "<p>Object to copy.</p>"
        }
      ],
      "description": "<p>Create a copy of the object without the undefined properties.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "cleanUndefinedProperties",
      "signatures": []
    },
    "lib/util.isCapitalized": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.isCapitalized",
      "params": [
        {
          "name": "string",
          "description": "<p>String to check.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Check if string starts with a captial letter.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "isCapitalized",
      "signatures": []
    },
    "lib/util.sync.findRules": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.findRules",
      "params": [
        {
          "name": "optionRules",
          "description": "<p>Rule modules.</p>",
          "types": [
            "Array",
            "string"
          ]
        },
        {
          "name": "defaultDir",
          "description": "<p>Default directory for rules.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Require the specified rule modules, either from the default location or from\nthe user-specified location.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.findRules",
      "signatures": []
    },
    "lib/util.sync.findFunctions": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.findFunctions",
      "params": [
        {
          "name": "optionFunctions"
        },
        {
          "name": "defaultDir"
        }
      ],
      "description": "<p>Require the specified function modules, either in the default location or\nthe user-specified location.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.findFunctions",
      "signatures": []
    },
    "lib/util.sync.findFile": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.findFile",
      "params": [
        {
          "name": "fileList",
          "description": "<p>Possible files to find.</p>",
          "types": [
            "Array"
          ]
        },
        {
          "name": "ifCb",
          "description": "<p>If one is found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "elseCb",
          "description": "<p>If one is not found, do this.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Find one of a list of files.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.findFile",
      "signatures": []
    },
    "lib/util.sync.findDir": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.findDir",
      "params": [
        {
          "name": "dirList",
          "description": "<p>Possible directories to find.</p>",
          "types": [
            "Array"
          ]
        },
        {
          "name": "ifCb",
          "description": "<p>If one is found, do this.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "elseCb",
          "description": "<p>If one is not found, do this.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Find one of a list of directories.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.findDir",
      "signatures": []
    },
    "lib/util.sync.compareFileDates": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.compareFileDates",
      "params": [
        {
          "name": "a",
          "description": "<p>Path to first file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "b",
          "description": "<p>Path to second file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with comparison value.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Compare the modified time stamps of two files.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.compareFileDates",
      "signatures": []
    },
    "lib/util.sync.toArray": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.toArray",
      "params": [
        {
          "name": "maybeArray",
          "description": "<p>Array or value.</p>"
        }
      ],
      "description": "<p>Take an array or a value, and if it&#39;s a value, wrap it in an array.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.toArray",
      "signatures": []
    },
    "lib/util.sync.localizePaths": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.localizePaths",
      "params": [
        {
          "name": "pathList",
          "description": "<p>List of absolute paths.</p>",
          "types": [
            "Array"
          ]
        }
      ],
      "description": "<p>Compress absolute paths down to minimal non-colliding lengths.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.localizePaths",
      "signatures": []
    },
    "lib/util.sync.cleanUndefinedProperties": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.cleanUndefinedProperties",
      "params": [
        {
          "name": "obj",
          "description": "<p>Object to copy.</p>"
        }
      ],
      "description": "<p>Create a copy of the object without the undefined properties.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.cleanUndefinedProperties",
      "signatures": []
    },
    "lib/util.sync.isCapitalized": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.isCapitalized",
      "params": [
        {
          "name": "string",
          "description": "<p>String to check.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Check if string starts with a captial letter.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.isCapitalized",
      "signatures": []
    },
    "lib/util.sync.async.forEachSeries": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.async.forEachSeries",
      "params": [
        {
          "name": "array"
        },
        {
          "name": "eachCb"
        },
        {
          "name": "finalCb"
        }
      ],
      "description": "<p>Synchronous forEachSeries, with an asynchronous signature. Because it&#39;s\nsynchronous, it can also be used as the forEach function.\n\n</p>\n<p>See the async module for details.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.async.forEachSeries",
      "signatures": []
    },
    "lib/util.sync.async.detect": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.async.detect",
      "params": [
        {
          "name": "array"
        },
        {
          "name": "passCb"
        },
        {
          "name": "resultCb"
        }
      ],
      "description": "<p>Synchronous detect, with an asynchronous signature.\n\n</p>\n<p>See the async module for details.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.async.detect",
      "signatures": []
    },
    "lib/util.sync.async.some": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.async.some",
      "params": [
        {
          "name": "array"
        },
        {
          "name": "passCb"
        },
        {
          "name": "doneCb"
        }
      ],
      "description": "<p>Synchronous some, with an asynchronous signature.\n\n</p>\n<p>See the async module for details.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.async.some",
      "signatures": []
    },
    "lib/util.sync.async.forEach": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/util.sync.async.forEach",
      "params": [
        {
          "name": "array"
        },
        {
          "name": "eachCb"
        },
        {
          "name": "finalCb"
        }
      ],
      "description": "<p>Synchronous forEachSeries, with an asynchronous signature. Because it&#39;s\nsynchronous, it can also be used as the forEach function.\n\n</p>\n<p>See the async module for details.</p>",
      "groups": [
        "lib/util"
      ],
      "name": "sync.async.forEach",
      "signatures": []
    },
    "lib/nice-ast": {
      "type": "module",
      "key": "lib/nice-ast",
      "name": "nice-ast",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/nice-ast.walk",
        "lib/nice-ast.walkEnd",
        "lib/nice-ast.extendAst",
        "lib/nice-ast.cleanAst",
        "lib/nice-ast.astFromFile",
        "lib/nice-ast.astFromSource",
        "lib/nice-ast.walkWithRules",
        "lib/nice-ast.pegParser",
        "lib/nice-ast.lispify",
        "lib/nice-ast.like",
        "lib/nice-ast.equal",
        "lib/nice-ast.parserForGrammar"
      ],
      "itemTypeCounts": {
        "function": 12
      }
    },
    "lib/nice-ast.walk": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.walk",
      "params": [
        {
          "name": "node",
          "description": "<p>AST node to walk.</p>",
          "types": [
            "AstNode",
            "Object"
          ],
          "properties": [
            {
              "name": ".type",
              "description": "<p>Each AST node needs a type.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Each AST node can optionally have a list of nodes to recurse.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            },
            {
              "name": ".type",
              "description": "<p>Each AST node needs a type.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Each AST node can optionally have a list of nodes to recurse.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            }
          ]
        },
        {
          "name": "beforeCb",
          "description": "<p>Function to call before recursing into node.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "afterCb",
          "description": "<p>Function to call after recursing into node.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Walks a tree of AST nodes.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "walk",
      "signatures": []
    },
    "lib/nice-ast.walkEnd": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.walkEnd",
      "params": [
        {
          "name": "node",
          "description": "<p>AST node to walk.</p>",
          "types": [
            "AstNode",
            "Object"
          ],
          "properties": [
            {
              "name": ".type",
              "description": "<p>Each AST node needs a type.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Each AST node can optionally have a list of nodes to\nrecurse.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            },
            {
              "name": ".type",
              "description": "<p>Each AST node needs a type.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Each AST node can optionally have a list of nodes to\nrecurse.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            }
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call before and after recursing into node.\nAfter recursing node, pseudo-node of type &quot;end&quot; will be passed to callback.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Walks a tree of AST nodes.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "walkEnd",
      "signatures": []
    },
    "lib/nice-ast.extendAst": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.extendAst",
      "params": [
        {
          "name": "node",
          "description": "<p>Plain object representing a node.</p>",
          "types": [
            "Object"
          ],
          "properties": [
            {
              "name": ".type",
              "description": "<p>Type of the node.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Child nodes that will also be converted.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            },
            {
              "name": ".type",
              "description": "<p>Type of the node.</p>",
              "types": [
                "String"
              ]
            },
            {
              "name": ".nodes",
              "description": "<p>Child nodes that will also be converted.</p>",
              "types": [
                "Array"
              ],
              "optional": true
            }
          ]
        },
        {
          "name": "parent",
          "description": "<p>Parent AstNode in the tree.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Takes a plain object representing a node, converts it to an AstNode and attaches\nit to a parent in an AstNode tree.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "extendAst",
      "signatures": []
    },
    "lib/nice-ast.cleanAst": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.cleanAst",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to convert.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Converts a node (and its descendants) into plain objects that can be serialized.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "cleanAst",
      "signatures": []
    },
    "lib/nice-ast.astFromFile": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.astFromFile",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "file",
          "description": "<p>File name.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with AST.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Convert file to AST.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "astFromFile",
      "signatures": []
    },
    "lib/nice-ast.astFromSource": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.astFromSource",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "source",
          "description": "<p>Source code.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "extension",
          "description": "<p>File extension for source file.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with AST.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Convert source code to an AST.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "astFromSource",
      "signatures": []
    },
    "lib/nice-ast.walkWithRules": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.walkWithRules",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "rules",
          "description": "<p>One or more rules file names.</p>",
          "types": [
            "Array",
            "String"
          ]
        },
        {
          "name": "defaultDir",
          "description": "<p>Default location for rules modules.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "ast",
          "description": "<p>Root of AST.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "nodeCb",
          "description": "<p>Function to call for each node.</p>",
          "types": [
            "function"
          ]
        },
        {
          "name": "finalCb",
          "description": "<p>Function to call when finished walking.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Walk a tree of AST nodes and apply rules.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "walkWithRules",
      "signatures": []
    },
    "lib/nice-ast.pegParser": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.pegParser",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "extension",
          "description": "<p>File extension.</p>",
          "types": [
            "String"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call with peg parser.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Given doctor options and a file extension, retrieve an appropriate peg parser.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "pegParser",
      "signatures": []
    },
    "lib/nice-ast.lispify": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.lispify",
      "params": [
        {
          "name": "node",
          "description": "<p>AST node to lispify.</p>",
          "types": [
            "AstNode",
            "Object"
          ]
        }
      ],
      "description": "<p>Convert a node to a lisp-like string, useful for debugging rules.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "lispify",
      "signatures": []
    },
    "lib/nice-ast.like": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.like",
      "params": [
        {
          "name": "a",
          "description": "<p>Node to test for comparison. Must have all the\nproperties of node b.</p>",
          "types": [
            "AstNode",
            "Object"
          ]
        },
        {
          "name": "b",
          "description": "<p>Node that has a partial set of node a&#39;s properties.</p>",
          "types": [
            "AstNode",
            "Object"
          ]
        }
      ],
      "description": "<p>Determine if a node is &quot;like&quot; another node, meaning it has all the properties of\nthat node.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "like",
      "signatures": []
    },
    "lib/nice-ast.equal": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.equal",
      "params": [
        {
          "name": "a",
          "description": "<p>Example node.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "b",
          "description": "<p>Node that should match a&#39;s properties.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "diff"
        }
      ],
      "description": "<p>Tests two AST nodes for equality.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "equal",
      "signatures": []
    },
    "lib/nice-ast.parserForGrammar": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/nice-ast.parserForGrammar",
      "params": [
        {
          "name": "grammarFile",
          "description": "<p>Name of grammar file.</p>",
          "types": [
            "String"
          ]
        }
      ],
      "description": "<p>Return the PEG parser for a given grammar file.</p>",
      "groups": [
        "lib/nice-ast"
      ],
      "name": "parserForGrammar",
      "signatures": []
    },
    "lib/ast-node": {
      "type": "module",
      "key": "lib/ast-node",
      "name": "ast-node",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/ast-node.exports-AstNode"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/ast-node.class.AstNode": {
      "type": "class",
      "module": "lib/ast-node",
      "key": "lib/ast-node.class.AstNode",
      "name": "AstNode",
      "groups": [
        "classes"
      ],
      "items": [
        "lib/ast-node.exports-AstNode",
        "lib/ast-node.class.AstNode.item",
        "lib/ast-node.class.AstNode.fix",
        "lib/ast-node.class.AstNode.index",
        "lib/ast-node.class.AstNode.walk",
        "lib/ast-node.class.AstNode.after",
        "lib/ast-node.class.AstNode.before",
        "lib/ast-node.class.AstNode.prepend",
        "lib/ast-node.class.AstNode.append",
        "lib/ast-node.class.AstNode.remove",
        "lib/ast-node.class.AstNode.lispify",
        "lib/ast-node.class.AstNode.like",
        "lib/ast-node.class.AstNode.equal",
        "lib/ast-node.class.AstNode.parser",
        "lib/ast-node.class.AstNode.likeSource",
        "lib/ast-node.class.AstNode.ast",
        "lib/ast-node.class.AstNode.fromSource",
        "lib/ast-node.class.AstNode.nodeFromSource"
      ],
      "itemTypeCounts": {
        "module-function": 1,
        "function": 17
      }
    },
    "lib/ast-node.exports-AstNode": {
      "type": "module-function",
      "isConstructor": true,
      "key": "lib/ast-node.exports-AstNode",
      "params": [
        {
          "name": "node",
          "description": "<p>Plain object to use as template for node.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "parent",
          "description": "<p>Parent node of this node.</p>",
          "types": [
            "AstNode"
          ],
          "optional": true
        }
      ],
      "classDescription": {
        "description": "<p>Represents an AST node.</p>"
      },
      "description": "<p>Creates an AST node from a plain object.</p>",
      "properties": [
        {
          "name": "parent",
          "description": "<p>Parent of this node.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "prev",
          "description": "<p>Previous sibling of this node.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "next",
          "description": "<p>Next sibling of this node.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "_items",
          "isPrivate": true
        }
      ],
      "examples": [
        "var node = new AstNode({type: 'string', value: 'Hello, world!'});",
        "var node = new AstNode({type: 'string', value: 'Hello, world!'});"
      ],
      "groups": [
        "lib/ast-node",
        "lib/ast-node.class.AstNode"
      ],
      "name": "AstNode",
      "signatures": []
    },
    "lib/ast-node.class.AstNode.item": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.item",
      "params": [
        {
          "name": "key",
          "description": "<p>Item key.</p>"
        },
        {
          "name": "value",
          "description": "<p>Item value.</p>"
        }
      ],
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "item",
      "signatures": [
        {
          "description": "<p>Gets an item value from a node. If the node doesn&#39;t have the item\nkey, a recursive search will continue up through the parents.</p>",
          "returns": {
            "description": "<p>Value for this item.</p>"
          },
          "arity": 1,
          "params": [
            {
              "name": "key",
              "description": "<p>Item key.</p>"
            }
          ]
        },
        {
          "description": "<p>Sets an item value for a particular node. Node items act like scoped\nvariables. Values set for a parent node can be seen by children nodes.</p>",
          "arity": 2,
          "params": [
            {
              "name": "key",
              "description": "<p>Item key.</p>"
            },
            {
              "name": "value",
              "description": "<p>Item value.</p>"
            }
          ]
        }
      ],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.fix": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.fix",
      "params": [
        {
          "name": "index"
        }
      ],
      "description": "<p>Properly connect siblings to this node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "fix",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.index": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.index",
      "params": [],
      "returns": {
        "description": "",
        "types": [
          "integer"
        ]
      },
      "description": "<p>Get the index of a node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "index",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.walk": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.walk",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to walk.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Walk this node and its children, using the registered walk method. When a\nnode is appended, this is used to run all the rules for the appended node and\nits children.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "walk",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.after": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.after",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to insert.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Insert node after this one.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "after",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.before": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.before",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to insert.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Insert node before this one.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "before",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.prepend": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.prepend",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to prepend.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Insert a new child node before any other child nodes.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "prepend",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.append": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.append",
      "params": [
        {
          "name": "node",
          "description": "<p>Node to append.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "description": "<p>Insert a new child node after any other child nodes.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "append",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.remove": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.remove",
      "params": [],
      "description": "<p>Remove this node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "remove",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.lispify": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.lispify",
      "params": [],
      "returns": {
        "description": "",
        "types": [
          "string"
        ]
      },
      "description": "<p>Return a lisp-like representation of this node. Useful for debugging rules.\nGives you a terse look at the AST.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "lispify",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.like": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.like",
      "params": [
        {
          "name": "node",
          "description": "<p>Node that has a subset of nodes/properties.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "returns": {
        "description": "",
        "types": [
          "boolean"
        ]
      },
      "description": "<p>Returns true if this node has everything that node has.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "like",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.equal": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.equal",
      "params": [
        {
          "name": "node",
          "description": "<p>Node that has identical nodes/properties.</p>",
          "types": [
            "AstNode"
          ]
        }
      ],
      "returns": {
        "description": "",
        "types": [
          "boolean"
        ]
      },
      "description": "<p>Return true if this node is idential to node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "equal",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.parser": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.parser",
      "params": [],
      "returns": {
        "description": "<p>PEG parser.</p>"
      },
      "description": "<p>Get the PEG parser used to create this AST.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "parser",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.likeSource": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.likeSource",
      "params": [
        {
          "name": "source",
          "description": "<p>Source code to parse and compare to this node.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "description": "<p>Compare this node to some arbitrary source. The source string will be\ncompiled to an AST, using the same grammar that was used to create this node.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "likeSource",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.ast": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.ast",
      "params": [],
      "returns": {
        "description": "<p>Plain object.</p>",
        "types": [
          "Object"
        ]
      },
      "description": "<p>Return an AST without the sibling and parent references.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "ast",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.fromSource": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.fromSource",
      "params": [
        {
          "name": "source",
          "description": "<p>Source code.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "returns": {
        "description": "<p>AST.</p>",
        "types": [
          "Object"
        ]
      },
      "description": "<p>Create an AST from source code.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "fromSource",
      "signatures": [],
      "isMethod": true
    },
    "lib/ast-node.class.AstNode.nodeFromSource": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/ast-node.class.AstNode.nodeFromSource",
      "params": [
        {
          "name": "source",
          "description": "<p>Source code.</p>",
          "types": [
            "string"
          ]
        }
      ],
      "returns": {
        "description": "<p>AST node.</p>",
        "types": [
          "Object"
        ]
      },
      "description": "<p>Create an AST node from source code.</p>",
      "groups": [
        "lib/ast-node.class.AstNode"
      ],
      "name": "nodeFromSource",
      "signatures": [],
      "isMethod": true
    },
    "lib/render": {
      "type": "module",
      "key": "lib/render",
      "name": "render",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/render.exports-render"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/render.exports-render": {
      "type": "module-function",
      "isConstructor": false,
      "key": "lib/render.exports-render",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "report",
          "description": "<p>Report generated by doctor.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call when rendering is complete.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Render the report with the render modules supplied in the options.</p>",
      "groups": [
        "lib/render"
      ],
      "name": "render",
      "signatures": []
    },
    "lib/report": {
      "type": "module",
      "key": "lib/report",
      "name": "report",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/report.exports-run"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/report.exports-run": {
      "type": "module-function",
      "isConstructor": false,
      "key": "lib/report.exports-run",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "ast",
          "description": "<p>AST.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call when finished.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Run an AST through a set of rules and return a report in a callback.</p>",
      "groups": [
        "lib/report"
      ],
      "name": "run",
      "signatures": []
    },
    "lib/report.class.Report": {
      "type": "class",
      "key": "lib/report.class.Report",
      "name": "Report",
      "groups": [
        "classes"
      ],
      "items": [
        "lib/report.class.Report.run",
        "lib/report.class.Report.item",
        "lib/report.class.Report.remove",
        "lib/report.class.Report.add",
        "lib/report.class.Report.home"
      ],
      "itemTypeCounts": {
        "function": 5
      }
    },
    "lib/report.class.Report.run": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.run",
      "params": [
        {
          "name": "cb",
          "description": "<p>Function to call when finished walking and applying rules\nto the AST.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Run the report through the supplied report rules.</p>",
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "run",
      "signatures": [],
      "isMethod": true
    },
    "lib/report.class.Report.item": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.item",
      "params": [
        {
          "name": "key",
          "description": "<p>Key of report item.</p>",
          "types": [
            "String"
          ]
        }
      ],
      "returns": {
        "description": "<p>Object representing a report item.</p>",
        "types": [
          "Object"
        ]
      },
      "description": "<p>Returns a report item.</p>",
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "item",
      "signatures": [],
      "isMethod": true
    },
    "lib/report.class.Report.remove": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.remove",
      "params": [
        {
          "name": "key",
          "description": "<p>Key of report item.</p>",
          "types": [
            "String"
          ]
        }
      ],
      "description": "<p>Removes a report item.</p>",
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "remove",
      "signatures": [],
      "isMethod": true
    },
    "lib/report.class.Report.add": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.add",
      "params": [
        {
          "name": "item",
          "description": "<p>Report item.</p>",
          "types": [
            "String"
          ]
        }
      ],
      "description": "<p>Adds a report item.</p>",
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "add",
      "signatures": [],
      "isMethod": true
    },
    "lib/report.class.Report.home": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/report.class.Report.home",
      "params": [
        {
          "name": "item"
        }
      ],
      "groups": [
        "lib/report.class.Report"
      ],
      "name": "home",
      "signatures": [
        {
          "description": "<p>Gets the key of the home item for the report.</p>",
          "returns": {
            "description": "<p>Key of the home item.</p>",
            "types": [
              "String"
            ]
          },
          "arity": 0,
          "params": []
        },
        {
          "description": "<p>Sets the key of the home item for the report.</p>",
          "arity": 1,
          "params": [
            {
              "name": "item",
              "description": "<p>Key of the home item.</p>",
              "types": [
                "String"
              ]
            }
          ]
        }
      ],
      "isMethod": true
    },
    "lib/transform": {
      "type": "module",
      "key": "lib/transform",
      "name": "transform",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/transform.exports-transform"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/transform.exports-transform": {
      "type": "module-function",
      "isConstructor": false,
      "key": "lib/transform.exports-transform",
      "params": [
        {
          "name": "options",
          "description": "<p>Doctor options.</p>",
          "types": [
            "Object"
          ]
        },
        {
          "name": "ast",
          "description": "<p>AST.</p>",
          "types": [
            "AstNode"
          ]
        },
        {
          "name": "cb",
          "description": "<p>Function to call when transformation is complete.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Transform the AST with the supplied transform rules.</p>",
      "groups": [
        "lib/transform"
      ],
      "name": "transform",
      "signatures": []
    },
    "lib/doctor": {
      "type": "module",
      "key": "lib/doctor",
      "name": "doctor",
      "description": "<p>Main module.</p>",
      "examples": [
        "var doctor = require('doctor');"
      ],
      "groups": [
        "modules"
      ],
      "items": [
        "lib/doctor.examine",
        "lib/doctor.harmony",
        "lib/doctor.hookEnterExit",
        "lib/doctor._callEnterHook",
        "lib/doctor._callExitHook",
        "lib/doctor.insertEnterExitHooksSync",
        "lib/doctor._callHook",
        "lib/doctor._wrapCall"
      ],
      "itemTypeCounts": {
        "function": 8
      }
    },
    "lib/doctor.examine": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor.examine",
      "params": [
        {
          "name": "options",
          "description": "<p>Options for doctor.</p>",
          "types": [
            "Object"
          ],
          "properties": [
            {
              "name": ".files",
              "description": "<p>One or more source files to inspect.</p>",
              "types": [
                "Array",
                "String"
              ]
            },
            {
              "name": ".output",
              "description": "<p>Directory or filename for where to output the report file. If true, uses\n    default output directory name of &quot;output&quot;.</p>",
              "types": [
                "String",
                "boolean"
              ]
            },
            {
              "name": ".view",
              "description": "<p>One or more view directories to merge into output directory. If true, uses\n    default view.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".report",
              "description": "<p>One or more report modules. If true, uses default report module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".transform",
              "description": "<p>One or more transform modules. If true, uses default transform module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".render",
              "description": "<p>One or more render modules. If true, uses default render module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".grammar",
              "description": "<p>Grammar file to use or a map of grammar files to use for each source\n    extension.</p>",
              "types": [
                "String",
                "Object"
              ]
            },
            {
              "name": ".files",
              "description": "<p>One or more source files to inspect.</p>",
              "types": [
                "Array",
                "String"
              ]
            },
            {
              "name": ".output",
              "description": "<p>Directory or filename for where to output the report file. If true, uses\n    default output directory name of &quot;output&quot;.</p>",
              "types": [
                "String",
                "boolean"
              ]
            },
            {
              "name": ".view",
              "description": "<p>One or more view directories to merge into output directory. If true, uses\n    default view.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".report",
              "description": "<p>One or more report modules. If true, uses default report module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".transform",
              "description": "<p>One or more transform modules. If true, uses default transform module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".render",
              "description": "<p>One or more render modules. If true, uses default render module.</p>",
              "types": [
                "Array",
                "String",
                "boolean"
              ]
            },
            {
              "name": ".grammar",
              "description": "<p>Grammar file to use or a map of grammar files to use for each source\n    extension.</p>",
              "types": [
                "String",
                "Object"
              ]
            }
          ]
        },
        {
          "name": "progressCb",
          "description": "<p>Function to call with progress messages.</p>",
          "types": [
            "function"
          ],
          "optional": true
        },
        {
          "name": "cb",
          "description": "<p>Function to call when doctor is finished.</p>",
          "types": [
            "function"
          ]
        }
      ],
      "description": "<p>Parses the AST of a set of JavaScript files, uses report rules to convert the\nAST into a report, and optionally combines the report with the view or\nrenders the report into an output format.</p>",
      "examples": [
        "var doctor = require('doctor');\nvar options = {\n  files: ['package.json'],\n  view: ['default', 'doctor']\n};\ndoctor.examine(options, function (err, report) {\n  console.log(JSON.stringify(report));\n})",
        "var doctor = require('doctor');\nvar options = {\n  files: ['package.json'],\n  view: ['default', 'doctor']\n};\ndoctor.examine(options, function (err, report) {\n  console.log(JSON.stringify(report));\n})"
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "examine",
      "signatures": []
    },
    "lib/doctor.harmony": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor.harmony",
      "params": [],
      "description": "<p><strong>EXPERIMENTAL!</strong> <strong>(and not even close to finished)</strong> Registers a compiler\nfor the .js extension that will compile harmony files to ECMAScript 5.</p>",
      "visibility": "private",
      "groups": [
        "lib/doctor"
      ],
      "name": "harmony",
      "signatures": [],
      "isPrivate": true
    },
    "lib/doctor.hookEnterExit": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor.hookEnterExit",
      "params": [
        {
          "name": "options",
          "description": "<p>{Object|RegExp} Pass in a regular expression apply the compiler\nonly to paths matching that regular expression.</p>"
        },
        {
          "name": "enterCb",
          "description": "<p>{function} Calls this function (passing it info) when a\nfunction is entered.</p>"
        },
        {
          "name": "exitCb",
          "description": "<p>{Fucntion} Calls this function (passing it info) when a function\nis exited.</p>"
        }
      ],
      "description": "<p><strong>EXPERIMENTAL!</strong> Registers a compiler for the .js extension that will catch\nfunction entry/exit.</p>",
      "examples": [
        "var doctor = require('doctor');\n\nfunction hookMessage(title, info) {\n  return title + \" \" + info.name + \":\\n\" +\n    \"  type:   \" + info.type + \"\\n\" +\n    \"  line:   \" + info.line + \"\\n\" +\n    \"  column: \" + info.column + \"\\n\" +\n    \"  path:   \" + info.filename;\n}\n\ndoctor.hookEnterExit(\n  /foobar/,\n  function (info) {\n    console.log(hookMessage(\"Enter\", info));\n  },\n  function (info) {\n    console.log(hookMessage(\"Exit\", info));\n  }\n);\n\nrequire('./foobar');",
        "var doctor = require('doctor');\n\nfunction hookMessage(title, info) {\n  return title + \" \" + info.name + \":\\n\" +\n    \"  type:   \" + info.type + \"\\n\" +\n    \"  line:   \" + info.line + \"\\n\" +\n    \"  column: \" + info.column + \"\\n\" +\n    \"  path:   \" + info.filename;\n}\n\ndoctor.hookEnterExit(\n  /foobar/,\n  function (info) {\n    console.log(hookMessage(\"Enter\", info));\n  },\n  function (info) {\n    console.log(hookMessage(\"Exit\", info));\n  }\n);\n\nrequire('./foobar');"
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "hookEnterExit",
      "signatures": []
    },
    "lib/doctor._callEnterHook": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor._callEnterHook",
      "params": [],
      "groups": [
        "lib/doctor"
      ],
      "name": "_callEnterHook",
      "signatures": [],
      "isPrivate": true
    },
    "lib/doctor._callExitHook": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor._callExitHook",
      "params": [],
      "groups": [
        "lib/doctor"
      ],
      "name": "_callExitHook",
      "signatures": [],
      "isPrivate": true
    },
    "lib/doctor.insertEnterExitHooksSync": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor.insertEnterExitHooksSync",
      "params": [
        {
          "name": "filename",
          "description": "<p>{String} Filename of file to trasform. Callback hooks are\nregistered to this filename.</p>"
        },
        {
          "name": "enterCb",
          "description": "<p>{function} Function to call when entering function. If exitCb\nis not defined, enterCb will be called for exit as well.</p>"
        },
        {
          "name": "exitCb",
          "description": "<p>{function} Function to call when exiting function.</p>",
          "optional": true
        },
        {
          "name": "sourceCb",
          "description": "<p>{function} Function to call when building the source for a function.</p>",
          "optional": true
        }
      ],
      "description": "<p><strong>EXPERIMENTAL</strong> Inserts enter/exit hooks into a JavaScript file. Registers\ncallback hooks for that file.</p>",
      "examples": [
        "var doctor = require('doctor');\n\nvar source = doctor.insertEnterExitHooksSync('foobar.js', function (info) {\n  console.log(JSON.stringify(info, null, 2));\n});\n\neval(source);",
        "var doctor = require('doctor');\n\nvar source = doctor.insertEnterExitHooksSync('foobar.js', function (info) {\n  console.log(JSON.stringify(info, null, 2));\n});\n\neval(source);"
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "insertEnterExitHooksSync",
      "signatures": []
    },
    "lib/doctor._callHook": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor._callHook",
      "params": [
        {
          "name": "type"
        },
        {
          "name": "filename"
        },
        {
          "name": "info"
        }
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "_callHook",
      "signatures": [],
      "isPrivate": true
    },
    "lib/doctor._wrapCall": {
      "type": "function",
      "isConstructor": false,
      "key": "lib/doctor._wrapCall",
      "params": [
        {
          "name": "fn"
        },
        {
          "name": "ctx"
        },
        {
          "name": "args"
        },
        {
          "name": "filename"
        },
        {
          "name": "info"
        }
      ],
      "groups": [
        "lib/doctor"
      ],
      "name": "_wrapCall",
      "signatures": [],
      "isPrivate": true
    },
    "lib/cli": {
      "type": "module",
      "key": "lib/cli",
      "name": "cli",
      "description": "<p>Command-line interface into doctor.</p>",
      "groups": [
        "modules"
      ],
      "items": [
        "lib/cli.exports-cli"
      ],
      "itemTypeCounts": {
        "module-function": 1
      }
    },
    "lib/cli.exports-cli": {
      "type": "module-function",
      "isConstructor": false,
      "key": "lib/cli.exports-cli",
      "params": [
        {
          "name": "argv",
          "description": "<p>Just the command-line arguments. In other words,\nprocess.argv.slice(2).</p>",
          "types": [
            "Object"
          ]
        }
      ],
      "description": "<p>Map command-line arguments to doctor&#39;s examine function.</p>",
      "groups": [
        "lib/cli"
      ],
      "name": "cli",
      "signatures": []
    },
    "document.README.md": {
      "key": "document.README.md",
      "name": "Overview",
      "type": "document",
      "content": "<h1>doctor</h1>\n<p><a href=\"http://travis-ci.org/jdeal/doctor\"><img src=\"https://secure.travis-ci.org/jdeal/doctor.png\" alt=\"Build Status\"></a>\n\n</p>\n<p><strong>Doctor is still under development, so be careful.</strong> It is probably stable enough to be useful, but no promises.\n\n</p>\n<p><img src=\"https://github.com/jdeal/doctor/raw/master/images/pinch-points-warning-143.png\" alt=\"pinch\">\n\n</p>\n<p>Doctor converts JavaScript source to documentation, using rules to rely on\nconventions so that comment tags are (mostly) not needed.\n\n</p>\n<h2>Say what?</h2>\n<p>Maybe a picture will help:\n\n</p>\n<p><img src=\"https://github.com/jdeal/doctor/raw/master/images/doctor-pipeline.png\" alt=\"pipeline\">\n\n</p>\n<p>Okay, maybe that needs some explanation.\n\n</p>\n<p>Source files are parsed using a JavaScript grammar. This pushes out a plain\nLisp-like AST. This is refined with some transform rules. The default transform\nrules also use a grammar to parse the JSDoc-style comment tags. This is to add\nin things that cannot be inferred from the JavaScript source, such as function\ndescription and parameter types.\n\n</p>\n<p>Rules are applied to the refined AST to output a report, which is just a flat\nJSON object containing items and groups of items. The report is optionally run\nthrough a render module to convert the report to some format other than a single\nJSON file.\n\n</p>\n<p>Doctor also provides an option that takes a number of view directories and\nmerges them together into a single output directory, along with the report\nfile(s). A default HTML/JavaScript view is provided to view the default report\nas HTML.\n\n</p>\n<p>Doctor has initial (rough) support for markdown as well, integrating that into\nthe report if passed along with the source.\n\n</p>\n<p>Because of its modular and somewhat pluggable design, you can hack in your own\ngrammars, rules, etc. and use it as a general-purpose AST analysis tool.\n\n</p>\n<h2>Installation</h2>\n<pre><code>npm install doctor</code></pre>\n<p>or if you want the latest\n\n</p>\n<pre><code>npm install git:github.com/jdeal/doctor.git</code></pre>\n<h2>Examples, please!</h2>\n<p>Note that these examples assume a shell that expands wildcards.\n\n</p>\n<p>This is how doctor documents itself from the command-line:\n\n</p>\n<pre><code>doctor lib/*.js *.md -v default -v doctor -o doc</code></pre>\n<p>You can see the documentation <a href=\"http://jdeal.github.com/doctor/doc\">here</a>.\n\n</p>\n<h2>Command-line usage</h2>\n<p>Dump a report file to the console:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js</code></pre>\n<p>To write out the report file, give it a directory:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js -o output</code></pre>\n<p>And it will write the report to a file named report.json. If you prefer a\ndifferent name:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js -o output/myreport.json</code></pre>\n<p>You can also pass package.json files to doctor. It will use the main property to\nfind the source file:\n\n</p>\n<pre><code>doctor package.json -o output</code></pre>\n<p>To output the default viewer along with your report:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js -o output -v default</code></pre>\n<p>To merge in your own files into the view, pass multiple views:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js -o output -v default -v ~/my-view</code></pre>\n<p>You can override the grammar if you feel adenturous:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js --grammar ~/my-better-grammar.pegjs</code></pre>\n<p>You can override the grammar for a specific file extension:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.foo --grammar.foo foo</code></pre>\n<p>You can add your own transform rules:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js -t default -t ~/more-tranform-rules.js</code></pre>\n<p>Or your own report rules:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js -r default -r ~/more-report-rules.js</code></pre>\n<p>You can use a custom renderer:\n\n</p>\n<pre><code>doctor myfile1.js myfile2.js --render ~/my-render.js</code></pre>\n<h2>Programmatic usage</h2>\n<p>All the same options are available programmatically.\n\n</p>\n<pre><code class=\"lang-js\">var doctor = require(&#39;doctor&#39;);\nvar options = {\n  files: [&#39;myfile1.js&#39;, &#39;myfile2.js&#39;],\n  view: [&#39;default&#39;, &#39;~/my-view&#39;],\n  grammar: &#39;~/my-better-grammar.pegjs&#39;,\n  transform: [&#39;default&#39;, &#39;~/more-tranform-rules.js&#39;],\n  report: [&#39;default&#39;, &#39;~/more-report-rules.js&#39;],\n  render: &#39;markdown&#39;\n};\ndoctor.examine(options, function (err, report) {\n  // done\n});</code></pre>\n<p>Note that the above options probably don&#39;t really make sense. The default viewer\ndoesn&#39;t work with output from the markdown renderer.\n</p>",
      "groups": [
        "documents"
      ],
      "isSorted": true,
      "isHome": true,
      "isHomePath": true
    }
  },
  "home": "document.README.md"
}